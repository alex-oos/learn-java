# 流程控制语句结构

## if 运算符

流程控制语句结构：
1、顺序结构：上面语句执行完，才轮到下面的语句。
2、分支结构：只执行其中的一个分支，其余分支就不执行
3、循环结构：某些语句重复执行

一、分支结构
（1）条件判断：if...else
（2）选择结构：switch...case

二、条件判断：if...else
（1）单分支
（2）双分支
（3）多分支
（4）嵌套

三、单分支
语法结构：
if(条件表达式){
当条件表达式为true，即条件成立时，需要执行的语句块;
}

执行的特点：
当某个条件成立，就执行，不成立就什么也不干

说明：
（1）if()中写条件表达式，必须是布尔类型
A：关系表达式
B：逻辑表达式
C：布尔变量
（2）如果{}中只有一个语句，那么可以省略{}
但是：习惯上，我们就算只有一个语句，也保留{}

四、双分支：if...else
语法结构：
if(条件表达式){
当条件表达式成立时，执行的语句块1;
}else{
当条件表达式不成立时，执行的语句块2;
}

执行的特点：
这两个分支只执行其中一个，
当条件表达式成立时，执行的语句块1;
当条件表达式不成立时，执行的语句块2;

说明：
（1）if()中写条件表达式，必须是布尔类型
A：关系表达式
B：逻辑表达式
C：布尔变量
（2）如果{}中只有一个语句，那么可以省略{}
但是：习惯上，我们就算只有一个语句，也保留{}

五、多分支结构
语法结构：
if(条件表达式1){
当条件表达式1成立，执行语句块1;
}else if(条件表达式2){
当条件表达式2成立，执行语句块2;
}【else if(条件表达式3){
当条件表达式2成立，执行语句块3;
}】
....
【else{
当以上所有的条件表达式都不成立，执行语句块n+1;
}
】

执行特点：
（1）先判断条件表达式1，如果条件表达式1成立，那么就执行语句块1，后面的分支统统都不看，也不执行
（2）如果条件表达式1不成立，接着看条件表达式2，如果条件表达式2成立，那么就执行语句块2，
前面的语句块1，和后面的语句块都不执行，后面的条件也不看了。
（3）依次类推
（4）如果所有的条件都不成立，如果此时存在单独的else，那么执行else中的语句块n+1，如果else不存在，那么就都不执行。

说明：
（1）【】表示可选，可能有可能没有
（2）所有的条件表达式都要是布尔值
（3）所有的分支，如果只有一个语句，对应的{}仍然可以省略，但是强烈建议都保留。
（4）如果多个if的条件的范围是互斥，没有重叠部分，那么是顺序可以调换
如果多个if的条件的范围是包含，有重叠部分，那么顺序有要求，范围小的在上，大的在下

选择结构
语法格式：
switch(表达式){
case 常量值1:
语句块1;
【break;】
case 常量值2:
语句块2;
【break;】
...
【
default:
语句块n+1;
【break;】
】
}

执行特点：
“入口”：
A：当表达式的值与其中一个case的常量值匹配，就从这个分支进入，一旦进入顺序往下执行
B：当表达式的值与所有的case都不匹配，如果此时存在default，就从default进入，一旦进入顺序往下执行
“出口”：
A：遇到switch的结束}
B：遇到break

说明：
（1）switch()中的表达式的类型也有要求：
只能是以下几种类型：byte,short,int,char四种基本数据类型，
JDK1.5以后允许支持 枚举类型（引用数据类型）
JDK1.7以后允许支持 String类型（引用数据类型）
（2）case后面必须是常量值或常量表达式
（3）case后面的常量值的类型必须与switch()中表达式的类型一致或兼容
（4）case后面的常量值不能重复

和if..else:
所有的分支情况，都可以使用if..else，换句话说，可以使用switch..case解决的，一定可以使用if..else。
但是当所有的判断都是常量值的等值判断的话，使用switch..case效率更高，可读性更好。
